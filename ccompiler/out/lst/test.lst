0001   0000             ; --- FILENAME: test.c
0002   0000             ; --- DATE:     30-10-2025 at 20:33:43
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; printf("\nHello World\n"); 
0012   0408             ; --- START FUNCTION CALL
0013   0408 26 75 0D      mov b, _s0 ; "\nHello World\n"
0014   040B FD AB         swp b
0015   040D D8            push b
0016   040E 07 1D 04      call printf
0017   0411 51 02 00      add sp, 2
0018   0414             ; --- END FUNCTION CALL
0019   0414             ; return 0; 
0020   0414 FD 2E 00 00   mov32 cb, $00000000
0020   0418 00 00 
0021   041A F9            leave
0022   041B 05 0B         syscall sys_terminate_proc
0023   041D             
0024   041D             printf:
0025   041D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0026   0420             ; char *p, *format_p; 
0027   0420 52 01 00      sub sp, 1
0028   0423 52 02 00      sub sp, 2
0029   0426             ; format_p = format; 
0030   0426 FA FE FF      lea d, [bp + -2] ; $format_p
0031   0429 DA            push d
0032   042A FA 05 00      lea d, [bp + 5] ; $format
0033   042D 2A            mov b, [d]
0034   042E 38 00 00      mov c, 0
0035   0431 E7            pop d
0036   0432 FD 43         mov [d], b
0037   0434             ; p = &format + 2; 
0038   0434 FA 00 00      lea d, [bp + 0] ; $p
0039   0437 DA            push d
0040   0438 FA 05 00      lea d, [bp + 5] ; $format
0041   043B 2D            mov b, d
0042   043C             ; --- START TERMS
0043   043C D7            push a
0044   043D 11            mov a, b
0045   043E FD 2E 02 00   mov32 cb, $00000002
0045   0442 00 00 
0046   0444 56            add b, a
0047   0445 E4            pop a
0048   0446             ; --- END TERMS
0049   0446 E7            pop d
0050   0447 FD 3E         mov [d], bl
0051   0449             ; for(;;){ 
0052   0449             _for1_init:
0053   0449             _for1_cond:
0054   0449             _for1_block:
0055   0449             ; if(!*format_p) break; 
0056   0449             _if2_cond:
0057   0449 FA FE FF      lea d, [bp + -2] ; $format_p
0058   044C 2A            mov b, [d]
0059   044D 38 00 00      mov c, 0
0060   0450 74            mov d, b
0061   0451 32            mov bl, [d]
0062   0452 A7 00         mov bh, 0
0063   0454 38 00 00      mov c, 0
0064   0457 C0 00 00      cmp b, 0
0065   045A FD 71         seq ; !
0066   045C C0 00 00      cmp b, 0
0067   045F C6 68 04      je _if2_else
0068   0462             _if2_TRUE:
0069   0462             ; break; 
0070   0462 0A 29 07      jmp _for1_exit ; for break
0071   0465 0A 16 07      jmp _if2_exit
0072   0468             _if2_else:
0073   0468             ; if(*format_p == '%'){ 
0074   0468             _if3_cond:
0075   0468 FA FE FF      lea d, [bp + -2] ; $format_p
0076   046B 2A            mov b, [d]
0077   046C 38 00 00      mov c, 0
0078   046F 74            mov d, b
0079   0470 32            mov bl, [d]
0080   0471 A7 00         mov bh, 0
0081   0473 38 00 00      mov c, 0
0082   0476             ; --- START RELATIONAL
0083   0476 D7            push a
0084   0477 11            mov a, b
0085   0478 FD 2E 25 00   mov32 cb, $00000025
0085   047C 00 00 
0086   047E B0            cmp a, b
0087   047F FD 71         seq ; ==
0088   0481 E4            pop a
0089   0482             ; --- END RELATIONAL
0090   0482 C0 00 00      cmp b, 0
0091   0485 C6 01 07      je _if3_else
0092   0488             _if3_TRUE:
0093   0488             ; format_p++; 
0094   0488 FA FE FF      lea d, [bp + -2] ; $format_p
0095   048B 2A            mov b, [d]
0096   048C 38 00 00      mov c, 0
0097   048F FD 77         inc b
0098   0491 FA FE FF      lea d, [bp + -2] ; $format_p
0099   0494 FD 43         mov [d], b
0100   0496 FD 7D         dec b
0101   0498             ; switch(*format_p){ 
0102   0498             _switch4_expr:
0103   0498 FA FE FF      lea d, [bp + -2] ; $format_p
0104   049B 2A            mov b, [d]
0105   049C 38 00 00      mov c, 0
0106   049F 74            mov d, b
0107   04A0 32            mov bl, [d]
0108   04A1 A7 00         mov bh, 0
0109   04A3 38 00 00      mov c, 0
0110   04A6             _switch4_comparisons:
0111   04A6 C1 6C         cmp bl, $6c
0112   04A8 C6 D9 04      je _switch4_case0
0113   04AB C1 4C         cmp bl, $4c
0114   04AD C6 D9 04      je _switch4_case1
0115   04B0 C1 64         cmp bl, $64
0116   04B2 C6 F1 05      je _switch4_case2
0117   04B5 C1 69         cmp bl, $69
0118   04B7 C6 F1 05      je _switch4_case3
0119   04BA C1 75         cmp bl, $75
0120   04BC C6 25 06      je _switch4_case4
0121   04BF C1 78         cmp bl, $78
0122   04C1 C6 59 06      je _switch4_case5
0123   04C4 C1 70         cmp bl, $70
0124   04C6 C6 59 06      je _switch4_case6
0125   04C9 C1 63         cmp bl, $63
0126   04CB C6 8D 06      je _switch4_case7
0127   04CE C1 73         cmp bl, $73
0128   04D0 C6 C1 06      je _switch4_case8
0129   04D3 0A F2 06      jmp _switch4_default
0130   04D6 0A FE 06      jmp _switch4_exit
0131   04D9             _switch4_case0:
0132   04D9             _switch4_case1:
0133   04D9             ; format_p++; 
0134   04D9 FA FE FF      lea d, [bp + -2] ; $format_p
0135   04DC 2A            mov b, [d]
0136   04DD 38 00 00      mov c, 0
0137   04E0 FD 77         inc b
0138   04E2 FA FE FF      lea d, [bp + -2] ; $format_p
0139   04E5 FD 43         mov [d], b
0140   04E7 FD 7D         dec b
0141   04E9             ; if(*format_p == 'd' || *format_p == 'i') 
0142   04E9             _if5_cond:
0143   04E9 FA FE FF      lea d, [bp + -2] ; $format_p
0144   04EC 2A            mov b, [d]
0145   04ED 38 00 00      mov c, 0
0146   04F0 74            mov d, b
0147   04F1 32            mov bl, [d]
0148   04F2 A7 00         mov bh, 0
0149   04F4 38 00 00      mov c, 0
0150   04F7             ; --- START RELATIONAL
0151   04F7 D7            push a
0152   04F8 11            mov a, b
0153   04F9 FD 2E 64 00   mov32 cb, $00000064
0153   04FD 00 00 
0154   04FF B0            cmp a, b
0155   0500 FD 71         seq ; ==
0156   0502 E4            pop a
0157   0503             ; --- END RELATIONAL
0158   0503             ; --- START LOGICAL OR
0159   0503 D7            push a
0160   0504 11            mov a, b
0161   0505 FA FE FF      lea d, [bp + -2] ; $format_p
0162   0508 2A            mov b, [d]
0163   0509 38 00 00      mov c, 0
0164   050C 74            mov d, b
0165   050D 32            mov bl, [d]
0166   050E A7 00         mov bh, 0
0167   0510 38 00 00      mov c, 0
0168   0513             ; --- START RELATIONAL
0169   0513 D7            push a
0170   0514 11            mov a, b
0171   0515 FD 2E 69 00   mov32 cb, $00000069
0171   0519 00 00 
0172   051B B0            cmp a, b
0173   051C FD 71         seq ; ==
0174   051E E4            pop a
0175   051F             ; --- END RELATIONAL
0176   051F FD A8         sor a, b ; ||
0177   0521 E4            pop a
0178   0522             ; --- END LOGICAL OR
0179   0522 C0 00 00      cmp b, 0
0180   0525 C6 48 05      je _if5_else
0181   0528             _if5_TRUE:
0182   0528             ; print_signed_long(*(long int*)p); 
0183   0528             ; --- START FUNCTION CALL
0184   0528 FA 00 00      lea d, [bp + 0] ; $p
0185   052B 32            mov bl, [d]
0186   052C A7 00         mov bh, 0
0187   052E 38 00 00      mov c, 0
0188   0531 74            mov d, b
0189   0532 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0190   0535 FD 39         mov c, b ; And place it into C
0191   0537 2A            mov b, [d] ; Lower Word in B
0192   0538 12            mov a, c
0193   0539 FD AA         swp a
0194   053B D7            push a
0195   053C FD AB         swp b
0196   053E D8            push b
0197   053F 07 2B 07      call print_signed_long
0198   0542 51 04 00      add sp, 4
0199   0545             ; --- END FUNCTION CALL
0200   0545 0A D4 05      jmp _if5_exit
0201   0548             _if5_else:
0202   0548             ; if(*format_p == 'u') 
0203   0548             _if6_cond:
0204   0548 FA FE FF      lea d, [bp + -2] ; $format_p
0205   054B 2A            mov b, [d]
0206   054C 38 00 00      mov c, 0
0207   054F 74            mov d, b
0208   0550 32            mov bl, [d]
0209   0551 A7 00         mov bh, 0
0210   0553 38 00 00      mov c, 0
0211   0556             ; --- START RELATIONAL
0212   0556 D7            push a
0213   0557 11            mov a, b
0214   0558 FD 2E 75 00   mov32 cb, $00000075
0214   055C 00 00 
0215   055E B0            cmp a, b
0216   055F FD 71         seq ; ==
0217   0561 E4            pop a
0218   0562             ; --- END RELATIONAL
0219   0562 C0 00 00      cmp b, 0
0220   0565 C6 88 05      je _if6_else
0221   0568             _if6_TRUE:
0222   0568             ; print_unsigned_long(*(unsigned long int*)p); 
0223   0568             ; --- START FUNCTION CALL
0224   0568 FA 00 00      lea d, [bp + 0] ; $p
0225   056B 32            mov bl, [d]
0226   056C A7 00         mov bh, 0
0227   056E 38 00 00      mov c, 0
0228   0571 74            mov d, b
0229   0572 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0230   0575 FD 39         mov c, b ; And place it into C
0231   0577 2A            mov b, [d] ; Lower Word in B
0232   0578 12            mov a, c
0233   0579 FD AA         swp a
0234   057B D7            push a
0235   057C FD AB         swp b
0236   057E D8            push b
0237   057F 07 02 09      call print_unsigned_long
0238   0582 51 04 00      add sp, 4
0239   0585             ; --- END FUNCTION CALL
0240   0585 0A D4 05      jmp _if6_exit
0241   0588             _if6_else:
0242   0588             ; if(*format_p == 'x') 
0243   0588             _if7_cond:
0244   0588 FA FE FF      lea d, [bp + -2] ; $format_p
0245   058B 2A            mov b, [d]
0246   058C 38 00 00      mov c, 0
0247   058F 74            mov d, b
0248   0590 32            mov bl, [d]
0249   0591 A7 00         mov bh, 0
0250   0593 38 00 00      mov c, 0
0251   0596             ; --- START RELATIONAL
0252   0596 D7            push a
0253   0597 11            mov a, b
0254   0598 FD 2E 78 00   mov32 cb, $00000078
0254   059C 00 00 
0255   059E B0            cmp a, b
0256   059F FD 71         seq ; ==
0257   05A1 E4            pop a
0258   05A2             ; --- END RELATIONAL
0259   05A2 C0 00 00      cmp b, 0
0260   05A5 C6 C8 05      je _if7_else
0261   05A8             _if7_TRUE:
0262   05A8             ; printx32(*(long int *)p); 
0263   05A8             ; --- START FUNCTION CALL
0264   05A8 FA 00 00      lea d, [bp + 0] ; $p
0265   05AB 32            mov bl, [d]
0266   05AC A7 00         mov bh, 0
0267   05AE 38 00 00      mov c, 0
0268   05B1 74            mov d, b
0269   05B2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0270   05B5 FD 39         mov c, b ; And place it into C
0271   05B7 2A            mov b, [d] ; Lower Word in B
0272   05B8 12            mov a, c
0273   05B9 FD AA         swp a
0274   05BB D7            push a
0275   05BC FD AB         swp b
0276   05BE D8            push b
0277   05BF 07 2D 0A      call printx32
0278   05C2 51 04 00      add sp, 4
0279   05C5             ; --- END FUNCTION CALL
0280   05C5 0A D4 05      jmp _if7_exit
0281   05C8             _if7_else:
0282   05C8             ; err("Unexpected format in printf."); 
0283   05C8             ; --- START FUNCTION CALL
0284   05C8 26 83 0D      mov b, _s1 ; "Unexpected format in printf."
0285   05CB FD AB         swp b
0286   05CD D8            push b
0287   05CE 07 8D 0A      call err
0288   05D1 51 02 00      add sp, 2
0289   05D4             ; --- END FUNCTION CALL
0290   05D4             _if7_exit:
0291   05D4             _if6_exit:
0292   05D4             _if5_exit:
0293   05D4             ; p = p + 4; 
0294   05D4 FA 00 00      lea d, [bp + 0] ; $p
0295   05D7 DA            push d
0296   05D8 FA 00 00      lea d, [bp + 0] ; $p
0297   05DB 32            mov bl, [d]
0298   05DC A7 00         mov bh, 0
0299   05DE 38 00 00      mov c, 0
0300   05E1             ; --- START TERMS
0301   05E1 D7            push a
0302   05E2 11            mov a, b
0303   05E3 FD 2E 04 00   mov32 cb, $00000004
0303   05E7 00 00 
0304   05E9 56            add b, a
0305   05EA E4            pop a
0306   05EB             ; --- END TERMS
0307   05EB E7            pop d
0308   05EC FD 3E         mov [d], bl
0309   05EE             ; break; 
0310   05EE 0A FE 06      jmp _switch4_exit ; case break
0311   05F1             _switch4_case2:
0312   05F1             _switch4_case3:
0313   05F1             ; print_signed(*(int*)p); 
0314   05F1             ; --- START FUNCTION CALL
0315   05F1 FA 00 00      lea d, [bp + 0] ; $p
0316   05F4 32            mov bl, [d]
0317   05F5 A7 00         mov bh, 0
0318   05F7 38 00 00      mov c, 0
0319   05FA 74            mov d, b
0320   05FB 2A            mov b, [d]
0321   05FC 38 00 00      mov c, 0
0322   05FF FD AB         swp b
0323   0601 D8            push b
0324   0602 07 BB 0A      call print_signed
0325   0605 51 02 00      add sp, 2
0326   0608             ; --- END FUNCTION CALL
0327   0608             ; p = p + 2; 
0328   0608 FA 00 00      lea d, [bp + 0] ; $p
0329   060B DA            push d
0330   060C FA 00 00      lea d, [bp + 0] ; $p
0331   060F 32            mov bl, [d]
0332   0610 A7 00         mov bh, 0
0333   0612 38 00 00      mov c, 0
0334   0615             ; --- START TERMS
0335   0615 D7            push a
0336   0616 11            mov a, b
0337   0617 FD 2E 02 00   mov32 cb, $00000002
0337   061B 00 00 
0338   061D 56            add b, a
0339   061E E4            pop a
0340   061F             ; --- END TERMS
0341   061F E7            pop d
0342   0620 FD 3E         mov [d], bl
0343   0622             ; break; 
0344   0622 0A FE 06      jmp _switch4_exit ; case break
0345   0625             _switch4_case4:
0346   0625             ; print_unsigned(*(unsigned int*)p); 
0347   0625             ; --- START FUNCTION CALL
0348   0625 FA 00 00      lea d, [bp + 0] ; $p
0349   0628 32            mov bl, [d]
0350   0629 A7 00         mov bh, 0
0351   062B 38 00 00      mov c, 0
0352   062E 74            mov d, b
0353   062F 2A            mov b, [d]
0354   0630 38 00 00      mov c, 0
0355   0633 FD AB         swp b
0356   0635 D8            push b
0357   0636 07 1E 0C      call print_unsigned
0358   0639 51 02 00      add sp, 2
0359   063C             ; --- END FUNCTION CALL
0360   063C             ; p = p + 2; 
0361   063C FA 00 00      lea d, [bp + 0] ; $p
0362   063F DA            push d
0363   0640 FA 00 00      lea d, [bp + 0] ; $p
0364   0643 32            mov bl, [d]
0365   0644 A7 00         mov bh, 0
0366   0646 38 00 00      mov c, 0
0367   0649             ; --- START TERMS
0368   0649 D7            push a
0369   064A 11            mov a, b
0370   064B FD 2E 02 00   mov32 cb, $00000002
0370   064F 00 00 
0371   0651 56            add b, a
0372   0652 E4            pop a
0373   0653             ; --- END TERMS
0374   0653 E7            pop d
0375   0654 FD 3E         mov [d], bl
0376   0656             ; break; 
0377   0656 0A FE 06      jmp _switch4_exit ; case break
0378   0659             _switch4_case5:
0379   0659             _switch4_case6:
0380   0659             ; printx16(*(int*)p); 
0381   0659             ; --- START FUNCTION CALL
0382   0659 FA 00 00      lea d, [bp + 0] ; $p
0383   065C 32            mov bl, [d]
0384   065D A7 00         mov bh, 0
0385   065F 38 00 00      mov c, 0
0386   0662 74            mov d, b
0387   0663 2A            mov b, [d]
0388   0664 38 00 00      mov c, 0
0389   0667 FD AB         swp b
0390   0669 D8            push b
0391   066A 07 23 0D      call printx16
0392   066D 51 02 00      add sp, 2
0393   0670             ; --- END FUNCTION CALL
0394   0670             ; p = p + 2; 
0395   0670 FA 00 00      lea d, [bp + 0] ; $p
0396   0673 DA            push d
0397   0674 FA 00 00      lea d, [bp + 0] ; $p
0398   0677 32            mov bl, [d]
0399   0678 A7 00         mov bh, 0
0400   067A 38 00 00      mov c, 0
0401   067D             ; --- START TERMS
0402   067D D7            push a
0403   067E 11            mov a, b
0404   067F FD 2E 02 00   mov32 cb, $00000002
0404   0683 00 00 
0405   0685 56            add b, a
0406   0686 E4            pop a
0407   0687             ; --- END TERMS
0408   0687 E7            pop d
0409   0688 FD 3E         mov [d], bl
0410   068A             ; break; 
0411   068A 0A FE 06      jmp _switch4_exit ; case break
0412   068D             _switch4_case7:
0413   068D             ; putchar(*(char*)p); 
0414   068D             ; --- START FUNCTION CALL
0415   068D FA 00 00      lea d, [bp + 0] ; $p
0416   0690 32            mov bl, [d]
0417   0691 A7 00         mov bh, 0
0418   0693 38 00 00      mov c, 0
0419   0696 74            mov d, b
0420   0697 32            mov bl, [d]
0421   0698 A7 00         mov bh, 0
0422   069A 38 00 00      mov c, 0
0423   069D DD            push bl
0424   069E 07 F4 08      call putchar
0425   06A1 51 01 00      add sp, 1
0426   06A4             ; --- END FUNCTION CALL
0427   06A4             ; p = p + 2; 
0428   06A4 FA 00 00      lea d, [bp + 0] ; $p
0429   06A7 DA            push d
0430   06A8 FA 00 00      lea d, [bp + 0] ; $p
0431   06AB 32            mov bl, [d]
0432   06AC A7 00         mov bh, 0
0433   06AE 38 00 00      mov c, 0
0434   06B1             ; --- START TERMS
0435   06B1 D7            push a
0436   06B2 11            mov a, b
0437   06B3 FD 2E 02 00   mov32 cb, $00000002
0437   06B7 00 00 
0438   06B9 56            add b, a
0439   06BA E4            pop a
0440   06BB             ; --- END TERMS
0441   06BB E7            pop d
0442   06BC FD 3E         mov [d], bl
0443   06BE             ; break; 
0444   06BE 0A FE 06      jmp _switch4_exit ; case break
0445   06C1             _switch4_case8:
0446   06C1             ; print(*(char**)p); 
0447   06C1             ; --- START FUNCTION CALL
0448   06C1 FA 00 00      lea d, [bp + 0] ; $p
0449   06C4 32            mov bl, [d]
0450   06C5 A7 00         mov bh, 0
0451   06C7 38 00 00      mov c, 0
0452   06CA 74            mov d, b
0453   06CB 2A            mov b, [d]
0454   06CC FD AB         swp b
0455   06CE D8            push b
0456   06CF 07 A2 0A      call print
0457   06D2 51 02 00      add sp, 2
0458   06D5             ; --- END FUNCTION CALL
0459   06D5             ; p = p + 2; 
0460   06D5 FA 00 00      lea d, [bp + 0] ; $p
0461   06D8 DA            push d
0462   06D9 FA 00 00      lea d, [bp + 0] ; $p
0463   06DC 32            mov bl, [d]
0464   06DD A7 00         mov bh, 0
0465   06DF 38 00 00      mov c, 0
0466   06E2             ; --- START TERMS
0467   06E2 D7            push a
0468   06E3 11            mov a, b
0469   06E4 FD 2E 02 00   mov32 cb, $00000002
0469   06E8 00 00 
0470   06EA 56            add b, a
0471   06EB E4            pop a
0472   06EC             ; --- END TERMS
0473   06EC E7            pop d
0474   06ED FD 3E         mov [d], bl
0475   06EF             ; break; 
0476   06EF 0A FE 06      jmp _switch4_exit ; case break
0477   06F2             _switch4_default:
0478   06F2             ; print("Error: Unknown argument type.\n"); 
0479   06F2             ; --- START FUNCTION CALL
0480   06F2 26 A0 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0481   06F5 FD AB         swp b
0482   06F7 D8            push b
0483   06F8 07 A2 0A      call print
0484   06FB 51 02 00      add sp, 2
0485   06FE             ; --- END FUNCTION CALL
0486   06FE             _switch4_exit:
0487   06FE 0A 16 07      jmp _if3_exit
0488   0701             _if3_else:
0489   0701             ; putchar(*format_p); 
0490   0701             ; --- START FUNCTION CALL
0491   0701 FA FE FF      lea d, [bp + -2] ; $format_p
0492   0704 2A            mov b, [d]
0493   0705 38 00 00      mov c, 0
0494   0708 74            mov d, b
0495   0709 32            mov bl, [d]
0496   070A A7 00         mov bh, 0
0497   070C 38 00 00      mov c, 0
0498   070F DD            push bl
0499   0710 07 F4 08      call putchar
0500   0713 51 01 00      add sp, 1
0501   0716             ; --- END FUNCTION CALL
0502   0716             _if3_exit:
0503   0716             _if2_exit:
0504   0716             ; format_p++; 
0505   0716 FA FE FF      lea d, [bp + -2] ; $format_p
0506   0719 2A            mov b, [d]
0507   071A 38 00 00      mov c, 0
0508   071D FD 77         inc b
0509   071F FA FE FF      lea d, [bp + -2] ; $format_p
0510   0722 FD 43         mov [d], b
0511   0724 FD 7D         dec b
0512   0726             _for1_update:
0513   0726 0A 49 04      jmp _for1_cond
0514   0729             _for1_exit:
0515   0729 F9            leave
0516   072A 09            ret
0517   072B             
0518   072B             print_signed_long:
0519   072B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0520   072E             ; char digits[10];  // fits 2,147,483,647 
0521   072E 52 0A 00      sub sp, 10
0522   0731             ; int i = 0; 
0523   0731 52 02 00      sub sp, 2
0524   0734             ; --- START LOCAL VAR INITIALIZATION
0525   0734 FA F5 FF      lea d, [bp + -11] ; $i
0526   0737 DA            push d
0527   0738 FD 2E 00 00   mov32 cb, $00000000
0527   073C 00 00 
0528   073E E7            pop d
0529   073F FD 43         mov [d], b
0530   0741             ; --- END LOCAL VAR INITIALIZATION
0531   0741             ; unsigned long int absval; 
0532   0741 52 04 00      sub sp, 4
0533   0744             ; if (num < 0) { 
0534   0744             _if8_cond:
0535   0744 FA 05 00      lea d, [bp + 5] ; $num
0536   0747 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0537   074A FD 39         mov c, b ; And place it into C
0538   074C 2A            mov b, [d] ; Lower Word in B
0539   074D             ; --- START RELATIONAL
0540   074D D7            push a
0541   074E FD D8         push g
0542   0750 11            mov a, b
0543   0751 FD 7A         mov g, c
0544   0753 FD 2E 00 00   mov32 cb, $00000000
0544   0757 00 00 
0545   0759 38 00 00      mov c, 0
0546   075C FD AF         cmp32 ga, cb
0547   075E FD 73         slt ; <
0548   0760 FD F1         pop g
0549   0762 E4            pop a
0550   0763             ; --- END RELATIONAL
0551   0763 C0 00 00      cmp b, 0
0552   0766 C6 C5 07      je _if8_else
0553   0769             _if8_TRUE:
0554   0769             ; putchar('-'); 
0555   0769             ; --- START FUNCTION CALL
0556   0769 FD 2E 2D 00   mov32 cb, $0000002d
0556   076D 00 00 
0557   076F DD            push bl
0558   0770 07 F4 08      call putchar
0559   0773 51 01 00      add sp, 1
0560   0776             ; --- END FUNCTION CALL
0561   0776             ; absval = (unsigned long int)(-(num + 1)) + 1; 
0562   0776 FA F1 FF      lea d, [bp + -15] ; $absval
0563   0779 DA            push d
0564   077A FA 05 00      lea d, [bp + 5] ; $num
0565   077D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0566   0780 FD 39         mov c, b ; And place it into C
0567   0782 2A            mov b, [d] ; Lower Word in B
0568   0783             ; --- START TERMS
0569   0783 D7            push a
0570   0784 FD D8         push g
0571   0786 11            mov a, b
0572   0787 FD 7A         mov g, c
0573   0789 FD 2E 01 00   mov32 cb, $00000001
0573   078D 00 00 
0574   078F 38 00 00      mov c, 0
0575   0792 FD 15         add32 cb, ga
0576   0794 FD F1         pop g
0577   0796 E4            pop a
0578   0797             ; --- END TERMS
0579   0797 12            mov a, c
0580   0798 95            not a
0581   0799 97            not b
0582   079A 55 01 00      add b, 1
0583   079D 5B 00 00      adc a, 0
0584   07A0 39            mov c, a
0585   07A1 A7 00         mov bh, 0
0586   07A3 38 00 00      mov c, 0
0587   07A6             ; --- START TERMS
0588   07A6 D7            push a
0589   07A7 FD D8         push g
0590   07A9 11            mov a, b
0591   07AA FD 7A         mov g, c
0592   07AC FD 2E 01 00   mov32 cb, $00000001
0592   07B0 00 00 
0593   07B2 38 00 00      mov c, 0
0594   07B5 FD 15         add32 cb, ga
0595   07B7 FD F1         pop g
0596   07B9 E4            pop a
0597   07BA             ; --- END TERMS
0598   07BA E7            pop d
0599   07BB FD 43         mov [d], b
0600   07BD 28            mov b, c
0601   07BE FD 44 02 00   mov [d + 2], b
0602   07C2 0A DF 07      jmp _if8_exit
0603   07C5             _if8_else:
0604   07C5             ; absval = (unsigned long int)num; 
0605   07C5 FA F1 FF      lea d, [bp + -15] ; $absval
0606   07C8 DA            push d
0607   07C9 FA 05 00      lea d, [bp + 5] ; $num
0608   07CC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0609   07CF FD 39         mov c, b ; And place it into C
0610   07D1 2A            mov b, [d] ; Lower Word in B
0611   07D2 A7 00         mov bh, 0
0612   07D4 38 00 00      mov c, 0
0613   07D7 E7            pop d
0614   07D8 FD 43         mov [d], b
0615   07DA 28            mov b, c
0616   07DB FD 44 02 00   mov [d + 2], b
0617   07DF             _if8_exit:
0618   07DF             ; if (absval == 0) { 
0619   07DF             _if9_cond:
0620   07DF FA F1 FF      lea d, [bp + -15] ; $absval
0621   07E2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0622   07E5 FD 39         mov c, b ; And place it into C
0623   07E7 2A            mov b, [d] ; Lower Word in B
0624   07E8             ; --- START RELATIONAL
0625   07E8 D7            push a
0626   07E9 FD D8         push g
0627   07EB 11            mov a, b
0628   07EC FD 7A         mov g, c
0629   07EE FD 2E 00 00   mov32 cb, $00000000
0629   07F2 00 00 
0630   07F4 38 00 00      mov c, 0
0631   07F7 FD AF         cmp32 ga, cb
0632   07F9 FD 71         seq ; ==
0633   07FB FD F1         pop g
0634   07FD E4            pop a
0635   07FE             ; --- END RELATIONAL
0636   07FE C0 00 00      cmp b, 0
0637   0801 C6 16 08      je _if9_exit
0638   0804             _if9_TRUE:
0639   0804             ; putchar('0'); 
0640   0804             ; --- START FUNCTION CALL
0641   0804 FD 2E 30 00   mov32 cb, $00000030
0641   0808 00 00 
0642   080A DD            push bl
0643   080B 07 F4 08      call putchar
0644   080E 51 01 00      add sp, 1
0645   0811             ; --- END FUNCTION CALL
0646   0811             ; return; 
0647   0811 F9            leave
0648   0812 09            ret
0649   0813 0A 16 08      jmp _if9_exit
0650   0816             _if9_exit:
0651   0816             ; while (absval > 0) { 
0652   0816             _while10_cond:
0653   0816 FA F1 FF      lea d, [bp + -15] ; $absval
0654   0819 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0655   081C FD 39         mov c, b ; And place it into C
0656   081E 2A            mov b, [d] ; Lower Word in B
0657   081F             ; --- START RELATIONAL
0658   081F D7            push a
0659   0820 FD D8         push g
0660   0822 11            mov a, b
0661   0823 FD 7A         mov g, c
0662   0825 FD 2E 00 00   mov32 cb, $00000000
0662   0829 00 00 
0663   082B 38 00 00      mov c, 0
0664   082E FD AF         cmp32 ga, cb
0665   0830 FD 81         sgu
0666   0832 FD F1         pop g
0667   0834 E4            pop a
0668   0835             ; --- END RELATIONAL
0669   0835 C0 00 00      cmp b, 0
0670   0838 C6 B6 08      je _while10_exit
0671   083B             _while10_block:
0672   083B             ; digits[i++] = '0' + (absval % 10); 
0673   083B FA F7 FF      lea d, [bp + -9] ; $digits
0674   083E D7            push a
0675   083F DA            push d
0676   0840 FA F5 FF      lea d, [bp + -11] ; $i
0677   0843 2A            mov b, [d]
0678   0844 38 00 00      mov c, 0
0679   0847 11            mov a, b
0680   0848 FD 77         inc b
0681   084A FA F5 FF      lea d, [bp + -11] ; $i
0682   084D FD 43         mov [d], b
0683   084F 27            mov b, a
0684   0850 E7            pop d
0685   0851 5A            add d, b
0686   0852 E4            pop a
0687   0853 DA            push d
0688   0854 FD 2E 30 00   mov32 cb, $00000030
0688   0858 00 00 
0689   085A             ; --- START TERMS
0690   085A D7            push a
0691   085B 11            mov a, b
0692   085C FA F1 FF      lea d, [bp + -15] ; $absval
0693   085F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0694   0862 FD 39         mov c, b ; And place it into C
0695   0864 2A            mov b, [d] ; Lower Word in B
0696   0865             ; --- START FACTORS
0697   0865 D7            push a
0698   0866 FD D8         push g
0699   0868 11            mov a, b
0700   0869 FD 7A         mov g, c
0701   086B FD 2E 0A 00   mov32 cb, $0000000a
0701   086F 00 00 
0702   0871 FD D8         push g ; save 'g' as the div instruction uses it
0703   0873 AE            div a, b ; %, a: quotient, b: remainder
0704   0874 11            mov a, b
0705   0875 FD F1         pop g
0706   0877 FD 38         mov c, g
0707   0879 27            mov b, a
0708   087A FD F1         pop g
0709   087C E4            pop a
0710   087D             ; --- END FACTORS
0711   087D FD 22 00 00   mov g, 0
0712   0881 FD 15         add32 cb, ga
0713   0883 E4            pop a
0714   0884             ; --- END TERMS
0715   0884 E7            pop d
0716   0885 FD 3E         mov [d], bl
0717   0887             ; absval = absval / 10; 
0718   0887 FA F1 FF      lea d, [bp + -15] ; $absval
0719   088A DA            push d
0720   088B FA F1 FF      lea d, [bp + -15] ; $absval
0721   088E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0722   0891 FD 39         mov c, b ; And place it into C
0723   0893 2A            mov b, [d] ; Lower Word in B
0724   0894             ; --- START FACTORS
0725   0894 D7            push a
0726   0895 FD D8         push g
0727   0897 11            mov a, b
0728   0898 FD 7A         mov g, c
0729   089A FD 2E 0A 00   mov32 cb, $0000000a
0729   089E 00 00 
0730   08A0 FD D8         push g ; save 'g' as the div instruction uses it
0731   08A2 AE            div a, b ; /, a: quotient, b: remainder
0732   08A3 FD F1         pop g
0733   08A5 FD 38         mov c, g
0734   08A7 27            mov b, a
0735   08A8 FD F1         pop g
0736   08AA E4            pop a
0737   08AB             ; --- END FACTORS
0738   08AB E7            pop d
0739   08AC FD 43         mov [d], b
0740   08AE 28            mov b, c
0741   08AF FD 44 02 00   mov [d + 2], b
0742   08B3 0A 16 08      jmp _while10_cond
0743   08B6             _while10_exit:
0744   08B6             ; while (i > 0) { 
0745   08B6             _while17_cond:
0746   08B6 FA F5 FF      lea d, [bp + -11] ; $i
0747   08B9 2A            mov b, [d]
0748   08BA 38 00 00      mov c, 0
0749   08BD             ; --- START RELATIONAL
0750   08BD D7            push a
0751   08BE 11            mov a, b
0752   08BF FD 2E 00 00   mov32 cb, $00000000
0752   08C3 00 00 
0753   08C5 B0            cmp a, b
0754   08C6 FD 7F         sgt ; >
0755   08C8 E4            pop a
0756   08C9             ; --- END RELATIONAL
0757   08C9 C0 00 00      cmp b, 0
0758   08CC C6 F2 08      je _while17_exit
0759   08CF             _while17_block:
0760   08CF             ; putchar(digits[--i]); 
0761   08CF             ; --- START FUNCTION CALL
0762   08CF FA F7 FF      lea d, [bp + -9] ; $digits
0763   08D2 D7            push a
0764   08D3 DA            push d
0765   08D4 FA F5 FF      lea d, [bp + -11] ; $i
0766   08D7 2A            mov b, [d]
0767   08D8 FD 7D         dec b
0768   08DA FA F5 FF      lea d, [bp + -11] ; $i
0769   08DD FD 43         mov [d], b
0770   08DF E7            pop d
0771   08E0 5A            add d, b
0772   08E1 E4            pop a
0773   08E2 32            mov bl, [d]
0774   08E3 A7 00         mov bh, 0
0775   08E5 38 00 00      mov c, 0
0776   08E8 DD            push bl
0777   08E9 07 F4 08      call putchar
0778   08EC 51 01 00      add sp, 1
0779   08EF             ; --- END FUNCTION CALL
0780   08EF 0A B6 08      jmp _while17_cond
0781   08F2             _while17_exit:
0782   08F2 F9            leave
0783   08F3 09            ret
0784   08F4             
0785   08F4             putchar:
0786   08F4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0787   08F7             ; --- BEGIN INLINE ASM SEGMENT
0788   08F7 FA 05 00      lea d, [bp + 5] ; $c
0789   08FA 1E            mov al, [d]
0790   08FB 23            mov ah, al
0791   08FC 19 00         mov al, 0
0792   08FE 05 03         syscall sys_io      ; char in AH
0793   0900             ; --- END INLINE ASM SEGMENT
0794   0900 F9            leave
0795   0901 09            ret
0796   0902             
0797   0902             print_unsigned_long:
0798   0902 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0799   0905             ; char digits[10]; 
0800   0905 52 0A 00      sub sp, 10
0801   0908             ; int i = 0; 
0802   0908 52 02 00      sub sp, 2
0803   090B             ; --- START LOCAL VAR INITIALIZATION
0804   090B FA F5 FF      lea d, [bp + -11] ; $i
0805   090E DA            push d
0806   090F FD 2E 00 00   mov32 cb, $00000000
0806   0913 00 00 
0807   0915 E7            pop d
0808   0916 FD 43         mov [d], b
0809   0918             ; --- END LOCAL VAR INITIALIZATION
0810   0918             ; if(num == 0){ 
0811   0918             _if18_cond:
0812   0918 FA 05 00      lea d, [bp + 5] ; $num
0813   091B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0814   091E FD 39         mov c, b ; And place it into C
0815   0920 2A            mov b, [d] ; Lower Word in B
0816   0921             ; --- START RELATIONAL
0817   0921 D7            push a
0818   0922 FD D8         push g
0819   0924 11            mov a, b
0820   0925 FD 7A         mov g, c
0821   0927 FD 2E 00 00   mov32 cb, $00000000
0821   092B 00 00 
0822   092D 38 00 00      mov c, 0
0823   0930 FD AF         cmp32 ga, cb
0824   0932 FD 71         seq ; ==
0825   0934 FD F1         pop g
0826   0936 E4            pop a
0827   0937             ; --- END RELATIONAL
0828   0937 C0 00 00      cmp b, 0
0829   093A C6 4F 09      je _if18_exit
0830   093D             _if18_TRUE:
0831   093D             ; putchar('0'); 
0832   093D             ; --- START FUNCTION CALL
0833   093D FD 2E 30 00   mov32 cb, $00000030
0833   0941 00 00 
0834   0943 DD            push bl
0835   0944 07 F4 08      call putchar
0836   0947 51 01 00      add sp, 1
0837   094A             ; --- END FUNCTION CALL
0838   094A             ; return; 
0839   094A F9            leave
0840   094B 09            ret
0841   094C 0A 4F 09      jmp _if18_exit
0842   094F             _if18_exit:
0843   094F             ; while (num > 0) { 
0844   094F             _while19_cond:
0845   094F FA 05 00      lea d, [bp + 5] ; $num
0846   0952 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0847   0955 FD 39         mov c, b ; And place it into C
0848   0957 2A            mov b, [d] ; Lower Word in B
0849   0958             ; --- START RELATIONAL
0850   0958 D7            push a
0851   0959 FD D8         push g
0852   095B 11            mov a, b
0853   095C FD 7A         mov g, c
0854   095E FD 2E 00 00   mov32 cb, $00000000
0854   0962 00 00 
0855   0964 38 00 00      mov c, 0
0856   0967 FD AF         cmp32 ga, cb
0857   0969 FD 81         sgu
0858   096B FD F1         pop g
0859   096D E4            pop a
0860   096E             ; --- END RELATIONAL
0861   096E C0 00 00      cmp b, 0
0862   0971 C6 EF 09      je _while19_exit
0863   0974             _while19_block:
0864   0974             ; digits[i++] = '0' + (num % 10); 
0865   0974 FA F7 FF      lea d, [bp + -9] ; $digits
0866   0977 D7            push a
0867   0978 DA            push d
0868   0979 FA F5 FF      lea d, [bp + -11] ; $i
0869   097C 2A            mov b, [d]
0870   097D 38 00 00      mov c, 0
0871   0980 11            mov a, b
0872   0981 FD 77         inc b
0873   0983 FA F5 FF      lea d, [bp + -11] ; $i
0874   0986 FD 43         mov [d], b
0875   0988 27            mov b, a
0876   0989 E7            pop d
0877   098A 5A            add d, b
0878   098B E4            pop a
0879   098C DA            push d
0880   098D FD 2E 30 00   mov32 cb, $00000030
0880   0991 00 00 
0881   0993             ; --- START TERMS
0882   0993 D7            push a
0883   0994 11            mov a, b
0884   0995 FA 05 00      lea d, [bp + 5] ; $num
0885   0998 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0886   099B FD 39         mov c, b ; And place it into C
0887   099D 2A            mov b, [d] ; Lower Word in B
0888   099E             ; --- START FACTORS
0889   099E D7            push a
0890   099F FD D8         push g
0891   09A1 11            mov a, b
0892   09A2 FD 7A         mov g, c
0893   09A4 FD 2E 0A 00   mov32 cb, $0000000a
0893   09A8 00 00 
0894   09AA FD D8         push g ; save 'g' as the div instruction uses it
0895   09AC AE            div a, b ; %, a: quotient, b: remainder
0896   09AD 11            mov a, b
0897   09AE FD F1         pop g
0898   09B0 FD 38         mov c, g
0899   09B2 27            mov b, a
0900   09B3 FD F1         pop g
0901   09B5 E4            pop a
0902   09B6             ; --- END FACTORS
0903   09B6 FD 22 00 00   mov g, 0
0904   09BA FD 15         add32 cb, ga
0905   09BC E4            pop a
0906   09BD             ; --- END TERMS
0907   09BD E7            pop d
0908   09BE FD 3E         mov [d], bl
0909   09C0             ; num = num / 10; 
0910   09C0 FA 05 00      lea d, [bp + 5] ; $num
0911   09C3 DA            push d
0912   09C4 FA 05 00      lea d, [bp + 5] ; $num
0913   09C7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0914   09CA FD 39         mov c, b ; And place it into C
0915   09CC 2A            mov b, [d] ; Lower Word in B
0916   09CD             ; --- START FACTORS
0917   09CD D7            push a
0918   09CE FD D8         push g
0919   09D0 11            mov a, b
0920   09D1 FD 7A         mov g, c
0921   09D3 FD 2E 0A 00   mov32 cb, $0000000a
0921   09D7 00 00 
0922   09D9 FD D8         push g ; save 'g' as the div instruction uses it
0923   09DB AE            div a, b ; /, a: quotient, b: remainder
0924   09DC FD F1         pop g
0925   09DE FD 38         mov c, g
0926   09E0 27            mov b, a
0927   09E1 FD F1         pop g
0928   09E3 E4            pop a
0929   09E4             ; --- END FACTORS
0930   09E4 E7            pop d
0931   09E5 FD 43         mov [d], b
0932   09E7 28            mov b, c
0933   09E8 FD 44 02 00   mov [d + 2], b
0934   09EC 0A 4F 09      jmp _while19_cond
0935   09EF             _while19_exit:
0936   09EF             ; while (i > 0) { 
0937   09EF             _while26_cond:
0938   09EF FA F5 FF      lea d, [bp + -11] ; $i
0939   09F2 2A            mov b, [d]
0940   09F3 38 00 00      mov c, 0
0941   09F6             ; --- START RELATIONAL
0942   09F6 D7            push a
0943   09F7 11            mov a, b
0944   09F8 FD 2E 00 00   mov32 cb, $00000000
0944   09FC 00 00 
0945   09FE B0            cmp a, b
0946   09FF FD 7F         sgt ; >
0947   0A01 E4            pop a
0948   0A02             ; --- END RELATIONAL
0949   0A02 C0 00 00      cmp b, 0
0950   0A05 C6 2B 0A      je _while26_exit
0951   0A08             _while26_block:
0952   0A08             ; putchar(digits[--i]); 
0953   0A08             ; --- START FUNCTION CALL
0954   0A08 FA F7 FF      lea d, [bp + -9] ; $digits
0955   0A0B D7            push a
0956   0A0C DA            push d
0957   0A0D FA F5 FF      lea d, [bp + -11] ; $i
0958   0A10 2A            mov b, [d]
0959   0A11 FD 7D         dec b
0960   0A13 FA F5 FF      lea d, [bp + -11] ; $i
0961   0A16 FD 43         mov [d], b
0962   0A18 E7            pop d
0963   0A19 5A            add d, b
0964   0A1A E4            pop a
0965   0A1B 32            mov bl, [d]
0966   0A1C A7 00         mov bh, 0
0967   0A1E 38 00 00      mov c, 0
0968   0A21 DD            push bl
0969   0A22 07 F4 08      call putchar
0970   0A25 51 01 00      add sp, 1
0971   0A28             ; --- END FUNCTION CALL
0972   0A28 0A EF 09      jmp _while26_cond
0973   0A2B             _while26_exit:
0974   0A2B F9            leave
0975   0A2C 09            ret
0976   0A2D             
0977   0A2D             printx32:
0978   0A2D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0979   0A30             ; --- BEGIN INLINE ASM SEGMENT
0980   0A30 FA 05 00      lea d, [bp + 5] ; $hex
0981   0A33 2B 02 00      mov b, [d+2]
0982   0A36 07 3F 0A      call print_u16x_printx32
0983   0A39 2A            mov b, [d]
0984   0A3A 07 3F 0A      call print_u16x_printx32
0985   0A3D             ; --- END INLINE ASM SEGMENT
0986   0A3D             ; return; 
0987   0A3D F9            leave
0988   0A3E 09            ret
0989   0A3F             ; --- BEGIN INLINE ASM SEGMENT
0990   0A3F             print_u16x_printx32:
0991   0A3F D7            push a
0992   0A40 D8            push b
0993   0A41 DD            push bl
0994   0A42 30            mov bl, bh
0995   0A43 07 61 0A      call _itoa_printx32        ; convert bh to char in A
0996   0A46 2F            mov bl, al        ; save al
0997   0A47 19 00         mov al, 0
0998   0A49 05 03         syscall sys_io        ; display AH
0999   0A4B 24            mov ah, bl        ; retrieve al
1000   0A4C 19 00         mov al, 0
1001   0A4E 05 03         syscall sys_io        ; display AL
1002   0A50 EA            pop bl
1003   0A51 07 61 0A      call _itoa_printx32        ; convert bh to char in A
1004   0A54 2F            mov bl, al        ; save al
1005   0A55 19 00         mov al, 0
1006   0A57 05 03         syscall sys_io        ; display AH
1007   0A59 24            mov ah, bl        ; retrieve al
1008   0A5A 19 00         mov al, 0
1009   0A5C 05 03         syscall sys_io        ; display AL
1010   0A5E E5            pop b
1011   0A5F E4            pop a
1012   0A60 09            ret
1013   0A61             _itoa_printx32:
1014   0A61 DA            push d
1015   0A62 D8            push b
1016   0A63 A7 00         mov bh, 0
1017   0A65 FD A4 04      shr bl, 4  
1018   0A68 74            mov d, b
1019   0A69 1F 7B 0A      mov al, [d + s_hex_digits_printx32]
1020   0A6C 23            mov ah, al
1021   0A6D E5            pop b
1022   0A6E D8            push b
1023   0A6F A7 00         mov bh, 0
1024   0A71 FD 87 0F      and bl, $0F
1025   0A74 74            mov d, b
1026   0A75 1F 7B 0A      mov al, [d + s_hex_digits_printx32]
1027   0A78 E5            pop b
1028   0A79 E7            pop d
1029   0A7A 09            ret
1030   0A7B 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1030   0A7F 34 35 36 37 
1030   0A83 38 39 41 42 
1030   0A87 43 44 45 46 
1031   0A8B             ; --- END INLINE ASM SEGMENT
1032   0A8B F9            leave
1033   0A8C 09            ret
1034   0A8D             
1035   0A8D             err:
1036   0A8D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1037   0A90             ; print(e); 
1038   0A90             ; --- START FUNCTION CALL
1039   0A90 FA 05 00      lea d, [bp + 5] ; $e
1040   0A93 2A            mov b, [d]
1041   0A94 38 00 00      mov c, 0
1042   0A97 FD AB         swp b
1043   0A99 D8            push b
1044   0A9A 07 A2 0A      call print
1045   0A9D 51 02 00      add sp, 2
1046   0AA0             ; --- END FUNCTION CALL
1047   0AA0 F9            leave
1048   0AA1 09            ret
1049   0AA2             
1050   0AA2             print:
1051   0AA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1052   0AA5             ; --- BEGIN INLINE ASM SEGMENT
1053   0AA5 FA 05 00      lea d, [bp + 5] ; $s
1054   0AA8 FD 2A         mov d, [d]
1055   0AAA             _puts_L1_print:
1056   0AAA 1E            mov al, [d]
1057   0AAB B9 00         cmp al, 0
1058   0AAD C6 B9 0A      jz _puts_END_print
1059   0AB0 23            mov ah, al
1060   0AB1 19 00         mov al, 0
1061   0AB3 05 03         syscall sys_io
1062   0AB5 79            inc d
1063   0AB6 0A AA 0A      jmp _puts_L1_print
1064   0AB9             _puts_END_print:
1065   0AB9             ; --- END INLINE ASM SEGMENT
1066   0AB9 F9            leave
1067   0ABA 09            ret
1068   0ABB             
1069   0ABB             print_signed:
1070   0ABB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1071   0ABE             ; char digits[5];  // enough for "-32768" 
1072   0ABE 52 05 00      sub sp, 5
1073   0AC1             ; int i = 0; 
1074   0AC1 52 02 00      sub sp, 2
1075   0AC4             ; --- START LOCAL VAR INITIALIZATION
1076   0AC4 FA FA FF      lea d, [bp + -6] ; $i
1077   0AC7 DA            push d
1078   0AC8 FD 2E 00 00   mov32 cb, $00000000
1078   0ACC 00 00 
1079   0ACE E7            pop d
1080   0ACF FD 43         mov [d], b
1081   0AD1             ; --- END LOCAL VAR INITIALIZATION
1082   0AD1             ; unsigned int absval; 
1083   0AD1 52 02 00      sub sp, 2
1084   0AD4             ; if (num < 0) { 
1085   0AD4             _if27_cond:
1086   0AD4 FA 05 00      lea d, [bp + 5] ; $num
1087   0AD7 2A            mov b, [d]
1088   0AD8 38 00 00      mov c, 0
1089   0ADB             ; --- START RELATIONAL
1090   0ADB D7            push a
1091   0ADC 11            mov a, b
1092   0ADD FD 2E 00 00   mov32 cb, $00000000
1092   0AE1 00 00 
1093   0AE3 B0            cmp a, b
1094   0AE4 FD 73         slt ; < (signed)
1095   0AE6 E4            pop a
1096   0AE7             ; --- END RELATIONAL
1097   0AE7 C0 00 00      cmp b, 0
1098   0AEA C6 21 0B      je _if27_else
1099   0AED             _if27_TRUE:
1100   0AED             ; putchar('-'); 
1101   0AED             ; --- START FUNCTION CALL
1102   0AED FD 2E 2D 00   mov32 cb, $0000002d
1102   0AF1 00 00 
1103   0AF3 DD            push bl
1104   0AF4 07 F4 08      call putchar
1105   0AF7 51 01 00      add sp, 1
1106   0AFA             ; --- END FUNCTION CALL
1107   0AFA             ; absval = (unsigned int)(-(num + 1)) + 1;  // safe for -32768 
1108   0AFA FA F8 FF      lea d, [bp + -8] ; $absval
1109   0AFD DA            push d
1110   0AFE FA 05 00      lea d, [bp + 5] ; $num
1111   0B01 2A            mov b, [d]
1112   0B02 38 00 00      mov c, 0
1113   0B05             ; --- START TERMS
1114   0B05 D7            push a
1115   0B06 11            mov a, b
1116   0B07 FD 2E 01 00   mov32 cb, $00000001
1116   0B0B 00 00 
1117   0B0D 56            add b, a
1118   0B0E E4            pop a
1119   0B0F             ; --- END TERMS
1120   0B0F FD 97         neg b
1121   0B11             ; --- START TERMS
1122   0B11 D7            push a
1123   0B12 11            mov a, b
1124   0B13 FD 2E 01 00   mov32 cb, $00000001
1124   0B17 00 00 
1125   0B19 56            add b, a
1126   0B1A E4            pop a
1127   0B1B             ; --- END TERMS
1128   0B1B E7            pop d
1129   0B1C FD 43         mov [d], b
1130   0B1E 0A 2F 0B      jmp _if27_exit
1131   0B21             _if27_else:
1132   0B21             ; absval = (unsigned int)num; 
1133   0B21 FA F8 FF      lea d, [bp + -8] ; $absval
1134   0B24 DA            push d
1135   0B25 FA 05 00      lea d, [bp + 5] ; $num
1136   0B28 2A            mov b, [d]
1137   0B29 38 00 00      mov c, 0
1138   0B2C E7            pop d
1139   0B2D FD 43         mov [d], b
1140   0B2F             _if27_exit:
1141   0B2F             ; if (absval == 0) { 
1142   0B2F             _if28_cond:
1143   0B2F FA F8 FF      lea d, [bp + -8] ; $absval
1144   0B32 2A            mov b, [d]
1145   0B33 38 00 00      mov c, 0
1146   0B36             ; --- START RELATIONAL
1147   0B36 D7            push a
1148   0B37 11            mov a, b
1149   0B38 FD 2E 00 00   mov32 cb, $00000000
1149   0B3C 00 00 
1150   0B3E B0            cmp a, b
1151   0B3F FD 71         seq ; ==
1152   0B41 E4            pop a
1153   0B42             ; --- END RELATIONAL
1154   0B42 C0 00 00      cmp b, 0
1155   0B45 C6 5A 0B      je _if28_exit
1156   0B48             _if28_TRUE:
1157   0B48             ; putchar('0'); 
1158   0B48             ; --- START FUNCTION CALL
1159   0B48 FD 2E 30 00   mov32 cb, $00000030
1159   0B4C 00 00 
1160   0B4E DD            push bl
1161   0B4F 07 F4 08      call putchar
1162   0B52 51 01 00      add sp, 1
1163   0B55             ; --- END FUNCTION CALL
1164   0B55             ; return; 
1165   0B55 F9            leave
1166   0B56 09            ret
1167   0B57 0A 5A 0B      jmp _if28_exit
1168   0B5A             _if28_exit:
1169   0B5A             ; while (absval > 0) { 
1170   0B5A             _while29_cond:
1171   0B5A FA F8 FF      lea d, [bp + -8] ; $absval
1172   0B5D 2A            mov b, [d]
1173   0B5E 38 00 00      mov c, 0
1174   0B61             ; --- START RELATIONAL
1175   0B61 D7            push a
1176   0B62 11            mov a, b
1177   0B63 FD 2E 00 00   mov32 cb, $00000000
1177   0B67 00 00 
1178   0B69 B0            cmp a, b
1179   0B6A FD 81         sgu ; > (unsigned)
1180   0B6C E4            pop a
1181   0B6D             ; --- END RELATIONAL
1182   0B6D C0 00 00      cmp b, 0
1183   0B70 C6 E0 0B      je _while29_exit
1184   0B73             _while29_block:
1185   0B73             ; digits[i++] = '0' + (absval % 10); 
1186   0B73 FA FC FF      lea d, [bp + -4] ; $digits
1187   0B76 D7            push a
1188   0B77 DA            push d
1189   0B78 FA FA FF      lea d, [bp + -6] ; $i
1190   0B7B 2A            mov b, [d]
1191   0B7C 38 00 00      mov c, 0
1192   0B7F 11            mov a, b
1193   0B80 FD 77         inc b
1194   0B82 FA FA FF      lea d, [bp + -6] ; $i
1195   0B85 FD 43         mov [d], b
1196   0B87 27            mov b, a
1197   0B88 E7            pop d
1198   0B89 5A            add d, b
1199   0B8A E4            pop a
1200   0B8B DA            push d
1201   0B8C FD 2E 30 00   mov32 cb, $00000030
1201   0B90 00 00 
1202   0B92             ; --- START TERMS
1203   0B92 D7            push a
1204   0B93 11            mov a, b
1205   0B94 FA F8 FF      lea d, [bp + -8] ; $absval
1206   0B97 2A            mov b, [d]
1207   0B98 38 00 00      mov c, 0
1208   0B9B             ; --- START FACTORS
1209   0B9B D7            push a
1210   0B9C FD D8         push g
1211   0B9E 11            mov a, b
1212   0B9F FD 7A         mov g, c
1213   0BA1 FD 2E 0A 00   mov32 cb, $0000000a
1213   0BA5 00 00 
1214   0BA7 FD D8         push g ; save 'g' as the div instruction uses it
1215   0BA9 AE            div a, b ; %, a: quotient, b: remainder
1216   0BAA 11            mov a, b
1217   0BAB FD F1         pop g
1218   0BAD FD 38         mov c, g
1219   0BAF 27            mov b, a
1220   0BB0 FD F1         pop g
1221   0BB2 E4            pop a
1222   0BB3             ; --- END FACTORS
1223   0BB3 56            add b, a
1224   0BB4 E4            pop a
1225   0BB5             ; --- END TERMS
1226   0BB5 E7            pop d
1227   0BB6 FD 3E         mov [d], bl
1228   0BB8             ; absval = absval / 10; 
1229   0BB8 FA F8 FF      lea d, [bp + -8] ; $absval
1230   0BBB DA            push d
1231   0BBC FA F8 FF      lea d, [bp + -8] ; $absval
1232   0BBF 2A            mov b, [d]
1233   0BC0 38 00 00      mov c, 0
1234   0BC3             ; --- START FACTORS
1235   0BC3 D7            push a
1236   0BC4 FD D8         push g
1237   0BC6 11            mov a, b
1238   0BC7 FD 7A         mov g, c
1239   0BC9 FD 2E 0A 00   mov32 cb, $0000000a
1239   0BCD 00 00 
1240   0BCF FD D8         push g ; save 'g' as the div instruction uses it
1241   0BD1 AE            div a, b ; /, a: quotient, b: remainder
1242   0BD2 FD F1         pop g
1243   0BD4 FD 38         mov c, g
1244   0BD6 27            mov b, a
1245   0BD7 FD F1         pop g
1246   0BD9 E4            pop a
1247   0BDA             ; --- END FACTORS
1248   0BDA E7            pop d
1249   0BDB FD 43         mov [d], b
1250   0BDD 0A 5A 0B      jmp _while29_cond
1251   0BE0             _while29_exit:
1252   0BE0             ; while (i > 0) { 
1253   0BE0             _while36_cond:
1254   0BE0 FA FA FF      lea d, [bp + -6] ; $i
1255   0BE3 2A            mov b, [d]
1256   0BE4 38 00 00      mov c, 0
1257   0BE7             ; --- START RELATIONAL
1258   0BE7 D7            push a
1259   0BE8 11            mov a, b
1260   0BE9 FD 2E 00 00   mov32 cb, $00000000
1260   0BED 00 00 
1261   0BEF B0            cmp a, b
1262   0BF0 FD 7F         sgt ; >
1263   0BF2 E4            pop a
1264   0BF3             ; --- END RELATIONAL
1265   0BF3 C0 00 00      cmp b, 0
1266   0BF6 C6 1C 0C      je _while36_exit
1267   0BF9             _while36_block:
1268   0BF9             ; putchar(digits[--i]); 
1269   0BF9             ; --- START FUNCTION CALL
1270   0BF9 FA FC FF      lea d, [bp + -4] ; $digits
1271   0BFC D7            push a
1272   0BFD DA            push d
1273   0BFE FA FA FF      lea d, [bp + -6] ; $i
1274   0C01 2A            mov b, [d]
1275   0C02 FD 7D         dec b
1276   0C04 FA FA FF      lea d, [bp + -6] ; $i
1277   0C07 FD 43         mov [d], b
1278   0C09 E7            pop d
1279   0C0A 5A            add d, b
1280   0C0B E4            pop a
1281   0C0C 32            mov bl, [d]
1282   0C0D A7 00         mov bh, 0
1283   0C0F 38 00 00      mov c, 0
1284   0C12 DD            push bl
1285   0C13 07 F4 08      call putchar
1286   0C16 51 01 00      add sp, 1
1287   0C19             ; --- END FUNCTION CALL
1288   0C19 0A E0 0B      jmp _while36_cond
1289   0C1C             _while36_exit:
1290   0C1C F9            leave
1291   0C1D 09            ret
1292   0C1E             
1293   0C1E             print_unsigned:
1294   0C1E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1295   0C21             ; char digits[5]; 
1296   0C21 52 05 00      sub sp, 5
1297   0C24             ; int i = 0; 
1298   0C24 52 02 00      sub sp, 2
1299   0C27             ; --- START LOCAL VAR INITIALIZATION
1300   0C27 FA FA FF      lea d, [bp + -6] ; $i
1301   0C2A DA            push d
1302   0C2B FD 2E 00 00   mov32 cb, $00000000
1302   0C2F 00 00 
1303   0C31 E7            pop d
1304   0C32 FD 43         mov [d], b
1305   0C34             ; --- END LOCAL VAR INITIALIZATION
1306   0C34             ; if(num == 0){ 
1307   0C34             _if37_cond:
1308   0C34 FA 05 00      lea d, [bp + 5] ; $num
1309   0C37 2A            mov b, [d]
1310   0C38 38 00 00      mov c, 0
1311   0C3B             ; --- START RELATIONAL
1312   0C3B D7            push a
1313   0C3C 11            mov a, b
1314   0C3D FD 2E 00 00   mov32 cb, $00000000
1314   0C41 00 00 
1315   0C43 B0            cmp a, b
1316   0C44 FD 71         seq ; ==
1317   0C46 E4            pop a
1318   0C47             ; --- END RELATIONAL
1319   0C47 C0 00 00      cmp b, 0
1320   0C4A C6 5F 0C      je _if37_exit
1321   0C4D             _if37_TRUE:
1322   0C4D             ; putchar('0'); 
1323   0C4D             ; --- START FUNCTION CALL
1324   0C4D FD 2E 30 00   mov32 cb, $00000030
1324   0C51 00 00 
1325   0C53 DD            push bl
1326   0C54 07 F4 08      call putchar
1327   0C57 51 01 00      add sp, 1
1328   0C5A             ; --- END FUNCTION CALL
1329   0C5A             ; return; 
1330   0C5A F9            leave
1331   0C5B 09            ret
1332   0C5C 0A 5F 0C      jmp _if37_exit
1333   0C5F             _if37_exit:
1334   0C5F             ; while (num > 0) { 
1335   0C5F             _while38_cond:
1336   0C5F FA 05 00      lea d, [bp + 5] ; $num
1337   0C62 2A            mov b, [d]
1338   0C63 38 00 00      mov c, 0
1339   0C66             ; --- START RELATIONAL
1340   0C66 D7            push a
1341   0C67 11            mov a, b
1342   0C68 FD 2E 00 00   mov32 cb, $00000000
1342   0C6C 00 00 
1343   0C6E B0            cmp a, b
1344   0C6F FD 81         sgu ; > (unsigned)
1345   0C71 E4            pop a
1346   0C72             ; --- END RELATIONAL
1347   0C72 C0 00 00      cmp b, 0
1348   0C75 C6 E5 0C      je _while38_exit
1349   0C78             _while38_block:
1350   0C78             ; digits[i++] = '0' + (num % 10); 
1351   0C78 FA FC FF      lea d, [bp + -4] ; $digits
1352   0C7B D7            push a
1353   0C7C DA            push d
1354   0C7D FA FA FF      lea d, [bp + -6] ; $i
1355   0C80 2A            mov b, [d]
1356   0C81 38 00 00      mov c, 0
1357   0C84 11            mov a, b
1358   0C85 FD 77         inc b
1359   0C87 FA FA FF      lea d, [bp + -6] ; $i
1360   0C8A FD 43         mov [d], b
1361   0C8C 27            mov b, a
1362   0C8D E7            pop d
1363   0C8E 5A            add d, b
1364   0C8F E4            pop a
1365   0C90 DA            push d
1366   0C91 FD 2E 30 00   mov32 cb, $00000030
1366   0C95 00 00 
1367   0C97             ; --- START TERMS
1368   0C97 D7            push a
1369   0C98 11            mov a, b
1370   0C99 FA 05 00      lea d, [bp + 5] ; $num
1371   0C9C 2A            mov b, [d]
1372   0C9D 38 00 00      mov c, 0
1373   0CA0             ; --- START FACTORS
1374   0CA0 D7            push a
1375   0CA1 FD D8         push g
1376   0CA3 11            mov a, b
1377   0CA4 FD 7A         mov g, c
1378   0CA6 FD 2E 0A 00   mov32 cb, $0000000a
1378   0CAA 00 00 
1379   0CAC FD D8         push g ; save 'g' as the div instruction uses it
1380   0CAE AE            div a, b ; %, a: quotient, b: remainder
1381   0CAF 11            mov a, b
1382   0CB0 FD F1         pop g
1383   0CB2 FD 38         mov c, g
1384   0CB4 27            mov b, a
1385   0CB5 FD F1         pop g
1386   0CB7 E4            pop a
1387   0CB8             ; --- END FACTORS
1388   0CB8 56            add b, a
1389   0CB9 E4            pop a
1390   0CBA             ; --- END TERMS
1391   0CBA E7            pop d
1392   0CBB FD 3E         mov [d], bl
1393   0CBD             ; num = num / 10; 
1394   0CBD FA 05 00      lea d, [bp + 5] ; $num
1395   0CC0 DA            push d
1396   0CC1 FA 05 00      lea d, [bp + 5] ; $num
1397   0CC4 2A            mov b, [d]
1398   0CC5 38 00 00      mov c, 0
1399   0CC8             ; --- START FACTORS
1400   0CC8 D7            push a
1401   0CC9 FD D8         push g
1402   0CCB 11            mov a, b
1403   0CCC FD 7A         mov g, c
1404   0CCE FD 2E 0A 00   mov32 cb, $0000000a
1404   0CD2 00 00 
1405   0CD4 FD D8         push g ; save 'g' as the div instruction uses it
1406   0CD6 AE            div a, b ; /, a: quotient, b: remainder
1407   0CD7 FD F1         pop g
1408   0CD9 FD 38         mov c, g
1409   0CDB 27            mov b, a
1410   0CDC FD F1         pop g
1411   0CDE E4            pop a
1412   0CDF             ; --- END FACTORS
1413   0CDF E7            pop d
1414   0CE0 FD 43         mov [d], b
1415   0CE2 0A 5F 0C      jmp _while38_cond
1416   0CE5             _while38_exit:
1417   0CE5             ; while (i > 0) { 
1418   0CE5             _while45_cond:
1419   0CE5 FA FA FF      lea d, [bp + -6] ; $i
1420   0CE8 2A            mov b, [d]
1421   0CE9 38 00 00      mov c, 0
1422   0CEC             ; --- START RELATIONAL
1423   0CEC D7            push a
1424   0CED 11            mov a, b
1425   0CEE FD 2E 00 00   mov32 cb, $00000000
1425   0CF2 00 00 
1426   0CF4 B0            cmp a, b
1427   0CF5 FD 7F         sgt ; >
1428   0CF7 E4            pop a
1429   0CF8             ; --- END RELATIONAL
1430   0CF8 C0 00 00      cmp b, 0
1431   0CFB C6 21 0D      je _while45_exit
1432   0CFE             _while45_block:
1433   0CFE             ; putchar(digits[--i]); 
1434   0CFE             ; --- START FUNCTION CALL
1435   0CFE FA FC FF      lea d, [bp + -4] ; $digits
1436   0D01 D7            push a
1437   0D02 DA            push d
1438   0D03 FA FA FF      lea d, [bp + -6] ; $i
1439   0D06 2A            mov b, [d]
1440   0D07 FD 7D         dec b
1441   0D09 FA FA FF      lea d, [bp + -6] ; $i
1442   0D0C FD 43         mov [d], b
1443   0D0E E7            pop d
1444   0D0F 5A            add d, b
1445   0D10 E4            pop a
1446   0D11 32            mov bl, [d]
1447   0D12 A7 00         mov bh, 0
1448   0D14 38 00 00      mov c, 0
1449   0D17 DD            push bl
1450   0D18 07 F4 08      call putchar
1451   0D1B 51 01 00      add sp, 1
1452   0D1E             ; --- END FUNCTION CALL
1453   0D1E 0A E5 0C      jmp _while45_cond
1454   0D21             _while45_exit:
1455   0D21 F9            leave
1456   0D22 09            ret
1457   0D23             
1458   0D23             printx16:
1459   0D23 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1460   0D26             ; --- BEGIN INLINE ASM SEGMENT
1461   0D26 FA 05 00      lea d, [bp + 5] ; $hex
1462   0D29 2A            mov b, [d]
1463   0D2A             print_u16x_printx16:
1464   0D2A DD            push bl
1465   0D2B 30            mov bl, bh
1466   0D2C 07 49 0D      call _itoa_printx16        ; convert bh to char in A
1467   0D2F 2F            mov bl, al        ; save al
1468   0D30 19 00         mov al, 0
1469   0D32 05 03         syscall sys_io        ; display AH
1470   0D34 24            mov ah, bl        ; retrieve al
1471   0D35 19 00         mov al, 0
1472   0D37 05 03         syscall sys_io        ; display AL
1473   0D39 EA            pop bl
1474   0D3A 07 49 0D      call _itoa_printx16        ; convert bh to char in A
1475   0D3D 2F            mov bl, al        ; save al
1476   0D3E 19 00         mov al, 0
1477   0D40 05 03         syscall sys_io        ; display AH
1478   0D42 24            mov ah, bl        ; retrieve al
1479   0D43 19 00         mov al, 0
1480   0D45 05 03         syscall sys_io        ; display AL
1481   0D47             ; --- END INLINE ASM SEGMENT
1482   0D47             ; return; 
1483   0D47 F9            leave
1484   0D48 09            ret
1485   0D49             ; --- BEGIN INLINE ASM SEGMENT
1486   0D49             _itoa_printx16:
1487   0D49 DA            push d
1488   0D4A D8            push b
1489   0D4B A7 00         mov bh, 0
1490   0D4D FD A4 04      shr bl, 4  
1491   0D50 74            mov d, b
1492   0D51 1F 63 0D      mov al, [d + s_hex_digits_printx16]
1493   0D54 23            mov ah, al
1494   0D55 E5            pop b
1495   0D56 D8            push b
1496   0D57 A7 00         mov bh, 0
1497   0D59 FD 87 0F      and bl, $0F
1498   0D5C 74            mov d, b
1499   0D5D 1F 63 0D      mov al, [d + s_hex_digits_printx16]
1500   0D60 E5            pop b
1501   0D61 E7            pop d
1502   0D62 09            ret
1503   0D63 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1503   0D67 34 35 36 37 
1503   0D6B 38 39 41 42 
1503   0D6F 43 44 45 46 
1504   0D73             ; --- END INLINE ASM SEGMENT
1505   0D73 F9            leave
1506   0D74 09            ret
1507   0D75             ; --- END TEXT SEGMENT
1508   0D75             
1509   0D75             ; --- BEGIN DATA SEGMENT
1510   0D75 0A 48 65 6C _s0: .db "\nHello World\n", 0
1510   0D79 6C 6F 20 57 
1510   0D7D 6F 72 6C 64 
1510   0D81 0A 00 
1511   0D83 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1511   0D87 70 65 63 74 
1511   0D8B 65 64 20 66 
1511   0D8F 6F 72 6D 61 
1511   0D93 74 20 69 6E 
1511   0D97 20 70 72 69 
1511   0D9B 6E 74 66 2E 
1511   0D9F 00 
1512   0DA0 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1512   0DA4 72 3A 20 55 
1512   0DA8 6E 6B 6E 6F 
1512   0DAC 77 6E 20 61 
1512   0DB0 72 67 75 6D 
1512   0DB4 65 6E 74 20 
1512   0DB8 74 79 70 65 
1512   0DBC 2E 0A 00 
1513   0DBF             
1514   0DBF C1 0D       _heap_top: .dw _heap
1515   0DC1 00          _heap: .db 0
1516   0DC2             ; --- END DATA SEGMENT
1517   0DC2             
1518   0DC2             .end
tasm: Number of errors = 0
